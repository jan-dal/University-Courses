import gmpy2
from gmpy2 import mpq, sqrt, invert, powmod
from cfrac import *

gmpy2.get_context().precision <<= 9
gmpy2.get_context().rational_division = True

def decrypt(p, q, n, e, c):
    pq = n - p - q + 1
    e1 = invert(e, pq)
    d = e1 % pq
    
    m = powmod(c, d, n)
    try:
        message = bytes.fromhex(hex(m)[2:]).decode(errors="ignore")
        return message
    except:
        pass

def solve_quadratic(n, c):
    b = n - c + 1
    sd = sqrt(b*b - (n << 2))
    return (b-sd)/2, (sd+b)/2

def break_rsa(e, n):
    cf = ContFrac(mpq(e, n), 2000)
    s = 0
    for p, q in cf:
        print(f"{p} / {q}")
        s ^= 1
        if s or q % 2 == 0:
            continue
        c = (e*q - 1) / p
        if c == mpz(c):
            x1, x2 = solve_quadratic(n, mpz(c))
            if x1 * x2 == n:
                return x2, x1
        
n = mpz(130687494429316880592587603591521383920412628811049308935752972814617747010315095971923145877064688137992902685596097216720996854853919218727159390021227148733855762386858555333362302124683761104846232605563413435009531762821185586791939352214160535318857072814374111130766141753918111259889897345003064525351)

e = mpz(28693214582397890025989589693388201307112484632946573521392115165335417643770107378187402457550786952163563146261313111502966020280758229808732825588892750625283697984499468762855956587026046369855833720847192378100305673971120013410423795029025305091127141827911114988375014692107707438719088975457125194099)

cipher = mpz(55454605216274283003615025402579985926872868938531978788960945200071288606272984986984693007941093017948228426576659044356115993101475334306953285769932350902758319431922420892596139683929338562320497889321445435632761748150943331239997895979747860404050845449692343927454617961984814625948913598527195055849)

p, q = break_rsa(e, n)
print()
print(f"p = {p}")
print(f"q = {q}")
print(f"{decrypt(mpz(p), mpz(q), n, e, cipher)}")
